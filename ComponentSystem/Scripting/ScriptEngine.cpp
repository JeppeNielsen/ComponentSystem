//
//  ScriptEngine.cpp
//  ComponentSystem
//
//  Created by Jeppe Nielsen on 25/01/16.
//  Copyright Â© 2016 Jeppe Nielsen. All rights reserved.
//

#include "ScriptEngine.hpp"
#include <iostream>
#include <dlfcn.h>
#include "Logic.hpp"
#include <fstream>
#include "IScriptSystem.hpp"

using namespace std;

vector<string> ScriptEngine::Compile(const string &cmd) {
    FILE*           fp;
    const int       SIZEBUF = 1234;
    char            buf [SIZEBUF];
    vector<string> out;
    
    if ((fp = popen(cmd.c_str (), "r")) == NULL) {
        return out;
    }
    string cur_string = "";
    while (fgets(buf, sizeof (buf), fp)) {
        cur_string += buf;
    }
    out.push_back(cur_string.substr (0, cur_string.size () - 1));
    pclose(fp);
    return out;
}

bool ScriptEngine::BuildDir(const std::string &dir) {

    WriteComponentIDsHeader("/Projects/ComponentSystem/ComponentSystem/LibCode/libGameObject.h");

    auto out = Compile(
        "/Users/Jeppe/Downloads/clang+llvm-3.7.0-x86_64-apple-darwin/bin/clang++ "
        "-dynamiclib "
        "-std=c++14 -stdlib=libc++ "
        //" -I/Projects/ComponentSystem/ComponentSystem/ComponentSystem/ "
        //" -I/Projects/ComponentSystem/ComponentSystem/meta/ "
        //" -I/Projects/ComponentSystem/ComponentSystem/Data/ "
        //" -I/Projects/ComponentSystem/ComponentSystem/Serialization/ "
        //" -I/Projects/ComponentSystem/ComponentSystem/Scripting/ "
        //" -I/Projects/ComponentSystem/ComponentSystem/tests/ "
        " -I/Projects/ComponentSystem/ComponentSystem/LibCode/ "
        " -I/Projects/ComponentSystem/ComponentSystem/Scripting/ "
        " /Projects/ComponentSystem/ComponentSystem/LibCode/ScriptEngine_autoGenerated.cpp "
        //" /Projects/ComponentSystem/ComponentSystem/tests/Logic.cpp "
        " engine.so "
        " -o libCode.so"// -O3"
        );
    for(auto s : out) {
        std::cout << s << std::endl;
    }
    return out.size() == 0;
}

void ScriptEngine::WriteComponentIDsHeader(const std::string &path) {
    
    GameWorld world;
    
    std::ofstream file;
    file.open(path);
    
    file << "#pragma once"<< std::endl;
    //file << "template<typename T> int GetComponentID() { return 0; }"<<std::endl;
    
    world.EnumerateComponentClasses([&file] (std::string name, int index) {
        file << "struct "<< name << ";"<<std::endl;
    });
    
    /*
    world.EnumerateComponentClasses([&file] (std::string name, int index) {
        file << "template<> int GetComponentID<"<< name << ">() { return "<<index<<"; }"<<std::endl;
    });
    */
    
    file << std::endl;
    
    file << "struct GameObject {"<<std::endl;
    file << "    virtual void* GetComponent(int componentID) = 0;"<<std::endl;
    file << "    virtual void* AddComponent(int componentID) = 0;"<<std::endl;
    file << "    template<typename T> T* GetComponent() { return (T*)0; }"<<std::endl;
    file << "    template<typename T> T* AddComponent() { return (T*)0; }"<<std::endl;
    file << "};"<<std::endl;
    
    world.EnumerateComponentClasses([&file] (std::string name, int index) {
        file<<"template<> " << name  << "* GameObject::GetComponent<"<< name << ">() { return ("<< name <<"*) GetComponent("<<index<<"); }"<<std::endl;
    });
    
    world.EnumerateComponentClasses([&file] (std::string name, int index) {
        file<<"template<> " << name  << "* GameObject::AddComponent<"<< name << ">() { return ("<< name <<"*) AddComponent("<<index<<"); }"<<std::endl;
    });
    
    //Transform* template<> GameObject::GetComponent<Transform>() { return (Transform*)GetComponent(0); }
    
    file.close();
}

bool ScriptEngine::Run() {
    
    void* handle = dlopen("./libCode.so", RTLD_LAZY);
    
    if (!handle) {
        cerr << "Cannot open library: " << dlerror() << '\n';
        return false;
    }
    
    cout << "Loading symbol hello.so...\n";
    typedef IScriptSystem* (*CreateSystem)(int);
    typedef int (*CountSystem)();
    typedef void (*DeleteSystem)(IScriptSystem*);

    dlerror();
    CreateSystem createSystem = (CreateSystem) dlsym(handle, "CreateSystem");
    const char *dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'CreateSystem': " << dlsym_error << '\n';
        dlclose(handle);
        return false;
    }
    
    CountSystem countSystem = (CountSystem) dlsym(handle, "CountSystem");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'CountSystem': " << dlsym_error << '\n';
        dlclose(handle);
        return false;
    }
    
    DeleteSystem deleteSystem = (DeleteSystem) dlsym(handle, "DeleteSystem");
    dlsym_error = dlerror();
    if (dlsym_error) {
        cerr << "Cannot load symbol 'DeleteSystem': " << dlsym_error << '\n';
        dlclose(handle);
        return false;
    }
    
    GameWorld world;
    
    GameObject* object = world.CreateObject();
   //
    
    for (int i=0; i<countSystem(); i++) {
        
        IScriptSystem* system = createSystem(i);
        
        system->ObjectAdded(object);
        world.Update(1.0f);
        system->Update(1.0f);
        
        auto transform = object->GetComponent<Transform>();
        
        std::cout << " Transform::x = "<< transform->x<< std::endl;
        
        deleteSystem(system);
    }
    
    // close the library
    cout << "Closing library...\n";
    dlclose(handle);

    return true;
}
